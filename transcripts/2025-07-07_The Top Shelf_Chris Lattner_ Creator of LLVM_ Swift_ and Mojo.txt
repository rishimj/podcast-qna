# Podcast Transcript
# Show: The Top Shelf
# Episode: Chris Lattner: Creator of LLVM, Swift, and Mojo
# YouTube URL: https://www.youtube.com/watch?v=ovYbgbrQ-v8
# Downloaded: 2025-07-19 20:57:56

first off hey everybody Welcome this is
going to be what we were referring to as
the top shelf where we get some pretty
high uh impact guests to come on and
kind of talk about what they've done and
we're hoping to get some pretty unique
angles to what we're asking and what
we're doing and today we have on here
Chris lner you might be probably one of
the most influential Engineers I think
of our time uh the things that you've
written affect millions of people
directly and indirectly potentially most
people on earth I would say that clang
and llvm play a huge role in affecting
people's everyday lives whether they
realize it or not uh and also you've
written Swift and now you're working on
mojo as kind of like the big highlights
of everything you've done uh pretty
impressive you have a PhD which is
already more impressive than most people
in chat they can't even believe phds
actually exist so very impressive uh I
think chat's most surprised you have a
PhD and you're not like still writing
haskal I think that's what what chat
considers one of your crowning
achievements yeah I wasn't I mean I I I
I had a great time in graduate school I
was an actually great graduate student
writing the papers and being the
academic was not my thing but it was
really amazing to get paid to work on
the stuff that I want to build so okay
when you said you weren't good at being
an academic what how do you get a PhD
how do you want to subject yourself to
that many years of school but not being
good at it uh I didn't so I went to
Illinois um with the goal of getting in
and out in a year with a master's degree
and then uh my adviser vickram uh nerd
sniped me and and start working on this
lvm thing and that became really cool
and I was having fun and then I decided
not leave so it's it's all his
fault dang that's actually you know nerd
sniping is an extremely powerful
technique and I realize that you can
solve a lot of problems by getting
somebody else excited about what you're
doing yeah well so I mean I I think that
something that defines what I work on is
that I work on it both because I you
know intellectually care about achieving
a thing but also because I just fall in
love with the problem and I what get
really excited about it and it's the
enthusiasm that drives this not just the
rational this needs to be solved in this
way for whatever reason I also love the
process of discovery and so being able
to work through something and and really
understand it because you you build into
this uh the space really gives you a
Hands-On way to understand and build
things and I'm H very fortunate that
some of it was useful to other people
too and that's that that's pretty cool I
do like this little bit of history that
I didn't know that it was lvm is just
the world's longest and largest nerd
snipe that's ever happened like I really
like this little tidbit
now yeah well I mean it's it's super
funny right I mean you talking about
Russ when we did the uh Mojo's faster
than Russ blog post a lot of people are
saying like oh my God this is this can't
be true rust has pil calls and uh you
know it'll even turn pil recursive
functions into uh for Loops things like
this right and the thing that I think
I'm pretty sure that 99 % of people
don't know or certainly the people that
are commenting don't understand is that
Russ does tail recursive for Loop
elimination nonsense because a
university student literally 21 years
ago got an idea for an algorithm
Implement into lvm and now here you go
Russ can do this thing and so he can go
look at tail recurve elimination if you
go all the way back 21 years in history
you can see me acing away having fun
learning how this little algorithm works
and now it's it's a cool thing that rust
and Swift and Julia and playing and like
all this universe of languages can I all
just get for free which is pretty cool
so what you're trying to say is you are
one of the top contributors to rust and
its
performance actually that would be
really interesting I am still by far the
top contributor to LM um including all
of it sub projects I haven't done that
cross comparison with rust you can go
look at my GitHub profile on github.com
latner and so like I'm still writing
thumb code and doing some stuff but the
uh I haven't done that cross comparison
to rust or other communities that's very
interesting all right so uh we we are
going to kind of go back and forth on
some questions and we're gonna let TJ
kind of start start us off yeah so one
of the things that I'm kind of
interested in as someone who loves some
uh not as popular languages is when you
started working on Swift at Apple uh one
of the things you had said is that there
were still a lot of people who loved
Objective C so from sort of like
a almost like The Human Side of the
problem the structural side of the
problem what what were some of the
things that you did to deal with uh
hesitancy I mean obviously for Swift
it's even bigger than a lot of the kinds
of introducing ne new technologies
because yeah you know you had to write
an entirely new language but there was
lots of people at Apple who were like oh
I've been writing Objective C for I
don't know longer than I've been alive
wait why why do we need this new thing
right so like how did you tackle that
inside of Apple
yeah so so great question let me let me
just give you some factoids on that so I
started working on Swift in 2010 it was
the nights and weekends project uh 2014
it launched publicly to the world and
then it got open source in 2016 right so
you're talking about just that six-year
time frame um by the time it launched
four years into its Journey um only
about 250 people knew about it at Apple
okay and this is because of Apple's
secrecy and like all the things that
apple both uh notorious for and also
wonderful at and so and so one of the
big questions I think you're getting at
is like how do you actually go
from like a crazy idea to something that
launches publicly to the world and now
millions of people use right and so um
so in the case of Swift it was literally
nights and weekends project that nobody
at Apple even knew about except for me
for a year and a half so that four years
a year and a half of it was just me
working on a thing to understand it to
explain I had a day job running several
really big teams and so it was a relief
Val after uh getting C++ to work and
clang and get the compiler to bootstrap
and build boost and like all these cs+
is a very formidable language to
implement and so you can't come out of
that without some PTSD and so Swift was
kind of releas well um by the time it
got interesting and it was I was
starting to understand it because again
I have to build things to really
understand it then I said hey management
uh what do you think about this project
right and the plus one apple I built up
enough credibility for delivering things
that they didn't immediately say go away
kid like you're not GNA like this is
this is dumb they kind of said well
that's very interesting but we have
other higher priority things to do right
and so um and in time I was granted the
ability to like have some of the people
that were already working for me like be
told about it first but then also start
contributing to it and kind of gain
momentum about three years in remember
it launched after four years about three
years in there became this really big
decision point and the decision Point
became does Apple actually put
significant resources into it and to
launch a language it's not just about
having a compiler you need to have a
book you need to have xcode integration
you need to have a debugger you need to
have apis that actually look nice you
have to it's a much bigger commitment to
be able to do this and so about three
years in there was a major series of
executive
reviews and that became a whole range of
conversations around should we do this
should we not like what does this look
like Etc and the push back and I think
this is actually by the way Apple at its
best because apple is capable of making
extremely hard decisions um but it puts
those decisions through a rigorous
process to actually you know the burden
is high and so in this case like the the
problems I had to solve were things like
okay cool um you're going to launch this
new language what if it fragments our
developer community in half what if some
people like this other people like
objective and now we've now made our
entire Community more pregnant right big
question another question was okay well
if Objective C has problems why not just
fix Objective C that's a very classic
kind of argument among Industries is
always why not just fix what we already
have right and so and so what we did was
we said okay said yes let's make obcy
better and so what we ended up doing is
we added modules objectivec literals Arc
reference uh AO me memory management to
objective which it didn't have
hilariously um and all these things and
what and what they were doing is twofold
one is pulling Objective C forward and
making it more productive and better and
improving obcy in place but also pulling
towards Swift because we need to talk to
obcy API so we need modules or we need
to be able to have automatic memory
management and so we needed Objective C
to actually have something rigorous and
and things like this right um a big
challenge that I faced was I kept
getting these like push backs like from
various very senior software leaders and
they they would ask these like really
elusive questions like that that are not
possible to answer and there were
questions like well how do we know it's
going to be better or how do we know
that somebody won't like this thing or
there's this one feature or this one
syntax or whatever and why why don't
blah blah blah blah right or I I don't
like the way this feels or looks or
whatever right and one of the things I
realized and TJ I think you're getting
at this is that um effectively all the
software engineers at Apple at that time
had grown up and joined Apple because of
Objective C the senior software leaders
worked at next like 15 years ago and
they they were there because of
objective c and they would ask these
questions like well Objective C isn't a
problem like our entire developer
Community is objective c the iPhone is
successful because of objective c and
this amazing and it is in its own way
it's this amazing combination of
dynamism and objects combined with the
power and performance of c and so right
why why why are you going to fix this it
ain't Bren right and what I realized is
that all these people because they had
joined for objective c and that's what
they knew inside and out and that's how
they had built their careers many of
them were now in these senior leadership
positions they weren't wrri they were
not writing code anymore and so what
Swift represented was a reset of their
expertise back to zero and so I'm a kind
of a dense person people are maybe not
my strong point but um but once I
realized that suddenly it became like
don't go engineer brain on uh this is
the way this is why we not going to
require semic Colones or whatever right
instead go into reassuring like this is
why it's going to be okay this is why
everything will transfer over we'll keep
all the apis blah blah blah blah blah
we'll keep everybody you know the the
important thing is the design patterns
from the Frameworks and the apis and
like all those come over without change
and and I was able to find a way to
explain it a way that mapped into the
value system made it so that people um
even people much more senior than me
would be heroes in their Journey still
and be able to do that and that that's
one of the things that allowed it to get
through another really big thing that
that I think allowed Swift to get
launched was um people would always ask
uh very romly okay well you know so far
a team of like five people 10 people
have built this
language um maybe 200 people most of
whom work for me uh have seen it now uh
how do we know it's good how do we know
that we're not going to like you know
we're going to launch this thing and
it's going to be embarrassing or
whatever and what and what I told people
is and again spent a bunch of time going
around and you know I make this all
sound linear but of course this is very
messy and complicated and in in and out
and lots of different things um what I
told what I realized is that the problem
was the Apple when it launches things
they want to say app developers can be
able to use this and therefore you're
protected from
incompatibility and so the Breakthrough
was when I realized look let's just tell
people it won't be compatible like Swift
you can use it you can sub it to the App
Store we will break your code because we
have not gotten a lot of miles on this
thing our goal is to make this good not
just nail it down and once I once we got
through that then exact leadership was
like oh well okay well if we're clear
about that then developers can opt out
of it and keep ring objectiv see that's
fine but that way it's not a oneway door
and that way we're not walking into a
trap if we make a mistake and it
provided a relief valve that allow
happen and so a lot of Swift again as
you're saying like on the human side and
on the culture side on the this kind of
side it was these kinds of challenges
which really have nothing to do with
compilers or semicon or the technical
stuff which is also super interesting um
but uh but was a big part of getting
getting Swift to happen another big
piece was um being able to show how we
could go beyond Objective C and so one
of the big pieces was memory safety and
so you know an object C you can't remove
pointers and have it still be C or
objective c like that that was that was
a big thing just OBC thing was yeah just
subjective yeah uh but the but then the
other piece was like how can we build
value ad experiences into xcode and
things like this and so I don't have a
huge amount of love for xcode
practically but um but uh xcode is very
important to Apple and so that was a big
case of it I'm very curious about how
you sold people on the ability to say
that we're going to have a language in
which will break backwards compatibility
because I mean to the this day people
are still fighting about python right
like I mean I still hear people upset
about the two to three break and so I
can't like that just seems like much
harder of a cell to be like you know
what we're going to go out there and
we're going to break you like H how how
did you managed to convince anybody that
that was a uh a good
idea because the minus minus and plus
plus I believe was your kind of primary
example that you gave about breaking
Swift so um well let me let me give you
again just time frame
uh Swift is just 10 years old now from
its launch it's launched in 2014 I was I
think it's still 20124 I lose track
sometimes but the uh but python 2 to3
took 15 years just for the
transition right if order magnitude
something like that right and so so so
not not only did we make a change in
Swift literally moved the entire
objective c community to completely
different
language in less time than python two to
three right so not not I mean maybe I'm
humble bragging a little bit here but
the um uh but how is that possible well
it's because it's a completely different
kind of transition so in the case of
python 2 to3 the entire Python program
had to move all at once and so all your
packages all your dependencies
everything and so if you have one um one
little thing that you depend on that
can't move or is incompatible then
you're stuck right in the case of
objective c to Swift there still a lot
of Objective C and C and C++ and all
this other stuff in a modern Swift app
like a lot of Apple's written a
tremendous amount of Swift code for sure
but they still have a lot of objective c
code in their stack and so that ability
to integrate and migrate and Inter
operate is so key and that was let me
tell you an extremely difficult
technical problem but that really
changed the nature of adoption and so
one of the things that allowed Swift to
get adopted very quickly is the app
developers could take their objective c
apps that they' written you know
sometimes a million lines of code and
then move one class over right and so
now you have that's cool that's really
cool yeah whole whole thing in Objective
C and I'm going to write some new
feature in Swift right and so this is
where I mean we take all these lessons
to Mojo and it's the same same ideas
right and so you make it so that you
don't have to be monolithically changing
everything all at once you actually work
the way the developers work which is
that they want to invest time into
things that are cool and shiny and new
and important for their business or
whatever um not the dusty deck code
that's fine I just want to ask one last
thing just sort of relating to those
sort of people sort of difficulties
there how did you set up like Apple's
huge first off so I mean obviously it's
difficult in one way to even have
conversations with people across your
team regardless right like getting 10
people to agree on something is hard
enough let alone however many Engineers
work at Apple but how did you sort of
create I don't know the culture or or
how did Apple create the culture where
you could actually have a conversation
about getting Swift to go anywhere like
that's super surprising from from my
side just from seeing like oh how do you
even get people to have a conversation
about changing the way things were like
culturally at a at a tech place in such
a big way right it's not just like oh
we're going to switch libraries for
logging um well so so I think that it's
it's a combination of multiple different
things one is um well how this apple
there's very Apple like any place has
positives and negatives and when I talk
about Apple I'm talking about Apple 2010
which is very different than Apple today
okay and I have been out out of Apple
for many years and so I can't speak to
Apple today I'm talking about kind of
old Apple when uh and so things are a
little bit different um but one of the
things that was really true is that
there was clear ownership and so the
head of software this guy named brron
surle amazing amazing human uh he built
a lot of Mac OS 10 he he led the team
through a lot of changes and did a lot
of the core technology within the stack
he happened to be an Objective C nerd
and he was pushing for things like
garbage collection and a bunch of other
things to try to modernize the language
um and so I got close to him because I
was helping drive and work on a lot of
these kinds of things um later he
decided to retire and move on and uh his
replacement Craig fedi also amazing
technical leader really understood this
stuff came into this and he had a bunch
of java experience and or gave platform
experience more broadly and um and so he
brought in A New Perspective and so this
idea of having more productive
programming languages wasn't just like a
complete
reject concept at the very top um and so
for them uh and this is again the thing
I love about Apple is that the at the
highest levels you have very smart very
strategic leaders who are um really
keyed into what matters for their
technology platform um and so the
challenge was I mean the
there are many challenging conversations
at that level for sure but but the
bigger challenge is getting contestant
in alignment and now you get these the
cross functional people that were
leading appkit or something and they'd
been writing Objective C for 20 years
and you know stuff like that and and
they they had strong opinions but they
didn't own it but they're important and
respected and so that was much more like
the Pol politicking and that's where
things were more complicated and there I
don't think there was any magic it was
more about yeah being P persistent about
being rational about being defensive
about hearing them and listening and
reacting about writing docs so that it
wasn't just hallway conversations like
okay well you have this concern let me
actually write it up so that can you can
scale the
conversation but but again a lot of the
thing that was very distinctly apple is
the secrecy thing and so yeah just put
in context uh Swift launch in 2014 about
250 people at Apple knew about it Apple
had thousands of software developers
thousands and thousands and you know
wasn't just app developers in the
audience at wwc whose heads exploded
when Swift launched it was roughly 90%
of software engineers at
Apple that's pretty crazy that is so
crazy You Dropped a feature as much for
internal Apple employees as for the
development community at the same
time by the way we have a new
language I love that but yeah so that
was that was an exciting day um uh we
had prepared the team a bit for that but
I didn't think we realiz quite how
interesting that would be but um but but
you flip it around right you talk about
decision
making there's there's lots of ways to
do it I'm just going to say this is the
way it worked back then it's way easier
to make decisions if you have fewer
Cooks in the kitchen facts yes so having
to negotiate with thousands of engineers
in an open culture would have made it
almost impossible to do anything versus
being able to get highle stakeholders
who are used to being rational who you
know things like this or the people that
you have to bring in and on board
because you have critical cross
functional dependencies and things like
this and you can kind of uh that's one
of the things that makes Apple able to
do uh very discontiguous things you know
at its best it can do things that nobody
else can do because um for example in
the iPhone launch they completely
sequestered the entire software team off
from the rest of the company and they
were able to go innovate and build
something without having to have a
million questions about well why not
this and why not that right that makes a
lot of sense to kind of force that I've
worked at simar worked in uh similar
sized companies and one thing that we
always did was uh informed Captain
someone that does farm for descent but
ultimately just at some point says okay
this is what we're doing it just it
doesn't matter what anybody else says I
am the captain I the captain now I'll
just say what we're going to do I I do
like that approach quite a bit all right
so something you said Chris uh in the
past on uh I think an interview with Lex
your second one says Progressive
disclosure of complexity I really like
this phrase and how do you apply that to
like modern language and what does that
mean and which of our current modern
languages is the worst at the
progressive disclosure of complexity oh
I mean I'll make fun of it because it's
easy to make fun of but Java is one of
the most egregious where it's like let
me show you hello world it's class Fu
public static void main system.out.print
lin. Square brackets. this right and so
like that's that's the failure right is
it's like okay I want to do hello world
now I have to know what classes are I
have to know what packages are need to
know what a razar I what what is all
like what this is that that's that's
what not having this is um so Swift the
original goal so I haven't been involved
in Swift development for about uh I mean
so I left Apple uh you can relate this
to Mojo too we don't have to relate this
to well yeah so I'll I'll do both um so
and I'll tell you Lessons Learned From
Swift right so Swift the original idea
was Factor complexity so you have really
powerful features they're available and
accessible within the language you don't
thrust them in people's face you make it
so that it's simple to get going and
then powerful as you dig in and so
Progressive disclosure complexity is
this UI Paradigm which is you know you
can have powerful things that are simple
to learn but then enable power users to
discover the power as they progress in
their experience instead of thrusting
all that complexity into their faces all
at once and the great thing about this
when well done is that um it means that
uh it's not just new user it's also
experienced programmers you have to put
Less in your head to get things done
because um you know normally you don't
need the complexity or the power right
um so that was that was a big a big
focus of my work on Swift and a big
focus of the other language uh massively
failed in my opinion by the way so
massive Lessons Learned Swift has turned
into a gigantic super complicated bag of
special cases special syntax special
stuff and it's all locally well
intentioned and there are some things
that they're trying to do with macros
and things like this to try to put into
more rigorous framework but one of the
challenges that Swift ran into and I'll
tell you what we're doing in Mojo it's
very different but one of the things
that Swift ran into is that it um scaled
the user base really quickly right so we
launched it and a lot of people were
ready to get off objective SE let's just
say right and so found pmf very very
quickly and so uh and so we got a ton of
users it had a lot of internal technical
debt because it was built very rapidly
and we didn't expect the adoption to be
so quick and um and so the whole team
was behind and then instead of fixing
the core what the team did um both when
I was there so partially my fault but
also subsequently is they started adding
all these special cases um there's also
some things like uh Swift UI added
result Builders and stuff like this
result Builders is a well-intentioned
metaprogramming thingy uh get rid of
commas to make Mak some code look better
on a slide right and so a lot of the
stuff got added under extreme time
pressure to enable a feature like Swift
UI and there are good aspects of it but
it's one of the reasons that Swift
compile times are not great and there's
there's like a bunch of stuff that kind
of feeds into that as well as just the
language gets more and more and more and
more more complicated now so it's still
a beautiful language it's amazing it's
got a lot of really great things in it
but I can't say that it's in a simple
language and so so now you Channel
forward to Mojo you say okay well again
10 10 years 15 years later Lessons
Learned right well with Mojo what we're
doing is we're both building it in the
open from the start so people can use it
provide feedback build stuff do this
we're telling people yes we're going to
not be stable we're going to optimize
and build for the right thing right a
lot of what we do within the team is
really channel into okay well there's
all these things people are asking for
so for example right now Mojo doesn't
have classes well why we know how to do
classes like that's like there's nothing
seriously can definitely do classes
that's not a big problem but what we're
doing is we we're drawing a line and
saying let's focus on this subset and
make it really really really really good
before we move on and also a lot of Mojo
being a python family language python is
really beautiful and really amazing at
forcing for example almost everything
via function call and so Mojo has
lifetimes has like all these has async
has like all these things that you need
to have in a modern language all these
things are kind of built into the
function and so if you can do function
calling right and you get all these
abstractions right at the bottom level
of the stack then you can build into and
compose onto this extremely quickly and
so my hope is that Mojo remains a much
simpler actually in practice language
than Swift is and now you don't have to
factor the complexity you just don't
have the complexity so so we'll see how
that goes I'm very optimistic but um
also MOJ has much more powerful met
programming facilities so you know
there's just a ton of special case
things like property decorators and
stuff like this got added to Swift that
are just kind of special cases of um a
more broad meta programming feature and
so you could subsume a lot of special
cases into you know one proper
subsystem so many many many Lessons
Learned From that I mean Swift is a
beautiful thing uh you know clang C++
it's a beautiful thing too um uh but
it's also a different Epoch of
Technology ology and you know you talk
about rust rust is also the same Epoch
of Technology as Swift and so a lot of
the lessons learn from going to Mojo or
learn both from Swift and from rust and
of course from CL before that which
Swift learned a lot
from so with go it is kind of like
extremely simple uh is that is that
actually Simplicity or is it kind of an
illusion of Simplicity that you get
offloaded into how you have to program
did you take any lessons from go in kind
of its you know like almost uh dogmatic
pursuit of
Simplicity um I have a ton of respect
for go um I have a lot less experience
with go than these other ones um I think
that go one of the lessons learn from go
is it initially positioned itself as a
systems programming language and it took
them a while to learn that they were
more of a cloud a cloud platform
language and um and so um and so some of
the decisions made around like garbage
collection and things like this and Etc
uh make sense given a cloud platform
language but um but in terms of
Simplicity
um I guess the lesson I would learn from
go and I mean one of the things I was
shocked at with go is that they actually
pulled in a generic system and it's
actually quite good um a lot of people
including like the Java Community they
started without generics they kind of
bolted it on it was never really that
great and so I was really impressed with
how they did that and I guess the lesson
I learned from that is that um what the
go community did was they drew the line
for a long time saying we will not have
generics let's see how it goes without
this thing let's get a lot of experience
and instead of saying woohoo let's have
our first generics model they they they
were very deliberate about it and they
learned a lot and then when they did it
they didn't just measure twice and cut
once they measured like 200 times and
then cut once and it turned out really
good and so I think that that would be
the thing I'd learned from go is you
don't
um just because everybody's telling you
a thing and this is something I face all
the time like everybody's trying to tell
me how to do Mojo or how like the best
way to do a thing or like how dare you
do this or like the universal truth of X
is y and it's like well there there's no
universal truth there's only trade-off I
do have some suggestions but we can save
those for later you know yeah
totally one thing I was uh kind of
wondering about sort of along these
lines of of this disclosure of
complexity and complexity sort of in a
language as someone who actually has
people using your languages and and
projects unlike many of us and many in
the chat
um why isn't functional programming
popular that's what I want to know I
love o camel many have been asking me to
ask you about oel why is it that we
can't get okl to be as popular as you
know JavaScript or go or something like
this I I'm committed to making it happen
but I'm just wondering what your
thoughts are I love o camel I wrote a
scheming for o camel a million years ago
made it properly tail recursive like o
cell is actually my favorite uh ml
functional language I'm just gonna cut
it to say o cel's actually my favorite
I'm getting the clip later we're putting
it on a t-shirt o cel's my favorite
Chris lner we're we made it Al I'm also
a huge fan of hcll and things like this
but for different reasons and okel I
think is a
much like I like that it's strict I like
that it is uh much simpler than the hcll
ecosystem and things like that um so the
the challenge with okam and um Jame
Folks at Jam Street and a bunch of other
people working on this but okel still
doesn't do threads well I mean I think
they're getting there um it still has a
it's very com so okam endlesss and
things like this don't work with modern
computers very well because everything
ends up being boxed and indirected
through pointers and so these days
unlike 30 years ago we have multi-level
caches and it turns out you know when I
was a kid I was taught algorithms and
it's like here's the algorithmic
complexity of a link list and here's the
algorithmic complexity of an array and
if you insert into the middle of an
array it's really slow if you insert in
the middle of a link list it's really
fast right that's generally wrong today
right because an array is all next to
each other in memory link list is
everywhere and so on a modern computer
if you even just walk a link list it'll
be 100 times slower than walking a ray
you know so so yeah it's technically
true at massive size is but um but a lot
of a lot of uh computer architecture
shifted the way you actually have to
write code and and things like oaml and
Lis and things like this are kind of
from that previous gener thing and so um
I don't know if it's answering your
question I love OK camel I think it's
amazing I think that it made um you know
pattern matching for example which is in
now many languages but a lot of these
good ideas were kind of buried in the
functional programming world for a long
time and um Swift brought some of that
forward which I think was really
fantastic andh rust also and many other
more modern languages are rediscovering
all this kind of stuff and so um I think
it's awesome
but I'll reemphasize I want to
reemphasize your question which is why
don't you think functional programming
even just as a concept catches on
because everyone who does functional
programming like starts wearing tie-dye
t-shirts and like gets converted to the
Church of functional programming almost
immediately so like why hasn't it caught
on okay so you want me to piss off your
entire community absolutely just 12
users there's only okay it's yeah it's
because it's because functional
programming strictly defined is dumb
like it doesn't actually make sense is
that is that is that polarizing enough
for great more
more so so again I'm being hyperbolic
right but the uh but here's why right
so so much of computing is about
defining mutable State and managing
functional programming says cool you can
do that and the way you manage mutable
state is by making an entire copy of the
data structure with the changes in the
new copy of the data structure this is
what generally people mean by functional
programming although you could Define in
lots of other different ways right and
so if you say it's purely functional
what that does is that means you have no
inplace
mutation okay here's the problem
computers they're all bags of mutable
State and so if you're saying I'm going
to reallocate and copy the entire data
structure to make a change somewhere in
a tree well it's just extremely slow and
so again back in the day maybe it was
okay and and for many youth cases it's
fine obviously right but but what Swift
did was Swift moved from let's have
functional programming to let's have
value
semantic and I probably don't want to go
into it deeply here but value sematics
are strictly more powerful than that
form of functional programming because
you get separation and logical
composition of behavior like functional
programming gives you but you also get
in place mutation and so it's a strictly
more powerful model it is uh much faster
in practice and obviously scaled to
millions of people and things like this
and so um so I mean so there are better
things than that that form of functional
programming now it's also super funny
because when you say what is functional
programming well some people say scull
is functional right and lots of lots of
schol programmers identify as functional
programmers even though they don't have
lack of M ation they don't it's not what
what you would cons like okel or hll is
is that right I mean a hll programmer
would say that that okam isn't properly
functional because it's not strict right
and it has mutable Fields so you can
update in place so it would be no longer
functional yeah yeah and so and so like
again like there's a holy war aspect
here but what what when I say functional
programming is done what I mean is in
practice like making an entire copy of a
data structure to change one part of it
like that that doesn't actually work
well for modern large scale applications
and so that that one little piece is is
that now I love all the people and so
they'll attack me for saying this but
that's okay I can take it I think um one
one I think if we if we can maybe Prime
if you're if you think it's good to just
like camp out on value semantics for
like five minutes because I do think
it's really cool and it goes with some
of the things from Mojo too as well as
how Mojo sort of does and and and sort
I've seen this popping up in a lot of
languages now obviously rust has this
has a lot of ideas about ownership and
borrowing Mojo has it now as well I see
you guys are working on different stuff
with how to manage refs and are refs
going to be transparently access okay
you got a bunch of stuff going on there
we can talk about those that's coool o
camel is um is adding this as well in a
way they have this oxidizing o camel
project where they're adding um like
locality and ownership so that they can
allocate on the stack instead of the
Heap there's like a sort of an explosion
of I think this concept across a lot of
languages so maybe you know give us your
pitch on what is and why value semantics
are cool because uh I I like them as
well yeah so I mean just uh I mean let
me give you a simple example you have an
array in a purely
functional system if you have an array
with 100 elements and you want to set
one value into the array you have to
copy 100 elements or you have to copy at
least the array part which points to the
elements something like this right and
so uh functional programming done
strictly that way destroys otation
destroys the the performance of your
program um so then what ends up
happening is that uh if you're building
into one of these systems you start
adding tons of complexity to work around
it and so I've built and maybe you have
as well like lots of really fancy
immutable data structures and there's
ways to use PR instead of arrays and
you know beef frees are like one of the
most under preor ever if you want to go
there but the uh um but it's just huge
amount of complexity and if you can do
in place mutation because you know you
have the only access to an array then
you totally can directly mutate it and
it actually composes out really well and
it just is better for ux it's better for
performance it just leads to a better at
scale programmers couldn't have to know
everything and know there's five
different ways to have an array they
just have an array makes it way simpler
and so mhm um but now what what it
requires is it requires either having
strong ownership like a rust or a Mojo
has for example or or being a little bit
Dynamic and then requiring you know
building on fancy compiler optimizations
and so Swift is in the being a little
bit Dynamic and then relying on fancy
compiler optimization camp and so that
it works really well for the Swift
community and and it's scaled really
well and I'm very happy about that um
but uh a lot of people don't want
Dynamic effects and stuff like this and
so if you can if you're up for more type
system annotations and stuff like that
then you can go with the I know I have
unique ownership kind of approach and
that that's also cool um one of the
things I'd like to achieve in Mojo is a
hybrid of both or you can have F Dynamic
thing for you know python programmer
just wants to write normal code and
doesn't care about a little bit of
overhead but then you you opt into more
strict annotations and now you can fully
control everything and the embedded
systems programmer gets all the overhead
out and if you can blend these two
worlds together then you get something I
think is the best of both worlds and it
kind of goes back to that Progressive
disclosure complexity right we want to
make it so the python you know that most
programmers most code written by most
programmers doesn't actually matter for
performance and so if that's the case
then hack something out have a lot of
fun go go nuts and then if you want
performance you can layer and type
annotations or things like that and just
get it over time and so this has been
done in many different systems over time
it's just never been done in the python
world because or I should be careful
what I say everything's been done in the
python world so uh but uh I would say
it's not been widely used in the python
world because um because of certain ways
that the type annotations work and
things like this which are a little bit
goofy in that system yeah that totally
makes sense I'm kind of
wondering along this line of the you
know you sort of start with python as
sort of this goal of Mojo it's a super
set of python eventually right and um
how do you prevent Mojo from becoming
python Plus+ if that's a clear question
related to C and
C++ yeah totally well so I think it it's
let me flip it around it is actually a
strong goal for Mojo to become a python
Plus+ that is the
goal right and so people ask me all the
time the other side which is your mojo
is the super set of
python uh how do you handle the fact
that python will keep changing Python's
not a dead language that was our fall
question yeah got it yeah and so and so
how do you square with this and so the
analogy I always give is look at C and
C++ C+ C was around for decades when C++
came about C++ was C with classes and
their whole idea was let's add classes
and then eventually templates and stuff
like this but it was a different
community that got standardized as a
different language and here you're
talking about running a committee speed
so it's glacial by today stand standards
but um but what end up happening is the
two languages and the two communities
were super were aware of each other and
people cohabitated you know programmers
cohabitated both Community right and so
what ended up happening is um classes of
code were built that work in C and C++
and then some people decided to go for
C++ because it added value right but uh
a lot of people don't know this but a
lot of features FL went both from C to
C++ obviously but also C++ back to C so
in C you have the void keyword for
example uh that was a C++ invention
but then see adopted so know that like
yeah and so there's a lot of things that
that that happen when you have two
communities with different objectives
and the the key thing you want is stay
true to your objective stay true to your
Charter be again I'm not anti- python
we're not trying to kill python I think
Python's amazing I love it um but we're
trying to solve the C and C++ and Cuda
and other parts of the Python ecosystem
in in one language that can scale
instead of saying okay here's the uh
glue layer and here's the actually get
stuff done layer and you have to use two
different layer languages to be
productive in terms of that like C C++
sort of comparison like
c i I mean maybe I maybe it has I'm not
aware of any like basically never it
feels like breaks backwards
compatibility even maybe to its uh
detriment but like python sometimes does
maybe they're a little more hesitant to
do that these days uh than they used to
be like has there been any example since
you started Mojo or any example you sort
of see along the horizon of like python
breaking something where then you're
like oh how are we going to handle this
fact that like python 310 does this and
312 does this and we need Mojo to run
like in both or is it like oh you can
only run Mojo with 312 or something like
H how is Mojo balancing those yeah so so
Guido is the one that scrolled me the
most on this by the way he's a guy that
cares a lot about python longterm
sustainability and compatibility and he
has all the Battle Scars to to share so
so there's two places where
compatibility with python matters for
Mojo so right now today in Mojo you can
import an arbitrary python package and
it just works okay and so this allows us
to embrace the entire python ecosystem
you don't have to write ffi or bindings
or wrappers or just works the way we do
that is we parse and interpret the
imported python package
with
cpython we just keep the standard
interpreter as it is and now there's a
separate pit of complexity on how do you
manage your python but we can't we can't
we can't fix cpython cpython is the
standard implementation of python with
The Interpreter and things like this
okay now fortunately there's a ton of
people working on cpython Lots people
trying to make it better trying to
remove the Gill which would be awesome
for Mojo by the way there's like a bunch
of work around python we don't have a
lot of value to add there right there's
the huge huge community of people doing
all that kind of stuff and so but what
we can do is we can use their public
apis and so we can talk to the the
python interpreter through niely stable
things and then python can go ahead and
change itself and it's fine it doesn't
doesn't matter to us at all um now
things like no Gill and stuff like that
are uh do change some things and so we
have to do minor adaptation in you know
for the big changes but no Gill is like
a five-year Quest or something thing for
Python and so like we can we can adapt
to things like that's fine um like I
said it takes less than five years to
build an entire
language you know um so the other side
of it though is we want to make it
really easy to move code into from
python into
Mojo and so as Mojo grows into a super
set of python which is not right now
right now it has no classes that's a
pretty big feature hole it's a tough one
no list comprehensions which you know
makes makes us sad I like writing them I
don't like reading them you know but
anyone who likes python says not to
write classes so at least you've picked
a good feature not to to implement right
I don't know about that yeah yeah that's
okay you can you can polarize people but
the I actually think class are pretty
cool but the uh uh but so anyway so so
we're not there yet but and so because
we're not there yet basically when
people move python code to Mojo like
they have to do a little bit of
rewriting right they they have to change
a class into inst struct have to do some
adaptation but what we've seen in the
community is people can move depending
on the kind of code right people can
move code really rapidly and it's really
easy and so you have to kind of learn
some of the tricks but once you do that
it doesn't take a lot of work and a lot
of it is because Mojo is it's different
in places where it needs to be different
where it's adding value but otherwise we
stay the same as Python and so one thing
I I'll share with you one thing I so I
generally love python python I think
it's a beautiful language one thing that
I don't super love is the postfix if
thing you say it's like X if condition
else y like I don't right just Square
honestly I don't love that but but guess
what that's what python does and so
that's what Mojo does let's not debate
it that's the thing right and so because
of that right what it means is that if
you're experienced with python whether
you love all the pieces or not like it
it makes it much easier to bring over
and L comprehension yeah will do that
it's we just haven't gone around to
either yeah now when you grow into a
full superet right that's I think what
you're what you're asking about as well
and then you say okay well now I'm
moving things from
python 3.85 to whatever you know and and
how does that handle and stuff like this
and so for that we can have so the the
the idea and this is a lesson learned
from Swift by the way is to have
migrator tools so it's not that the code
magically works like in Mojo we're
taking a new keyword right you can
decide what the new keyword is but we
want to be able to do that um that's
very important to make the language
consistent and coherent and things like
this and so we don't want to be ashamed
of doing that we want to do the right
thing for Mojo and so what we can do is
we make it so that okay there's a
mechanical tool that you run but then
just escapes the keyword adds an
underscore to it or something right if
you're using it and so we can make it
super easy to mechanically import and
that tool can then have a verin flag
that makes sense and also going back to
Swift right Swift was incompatible with
itself for multiple years and so uh as
as it came out with um with new new
features and it broke code what we did
was we provided a migrator the migrator
par old Swift Code and upgrade it and it
did a I don't know 90% job not 100% job
but it was still very useful and to help
the community move over and so this is
also the way I look at eventually being
syntax compatible with python is um you
know we technically will not be a
superet because we take a new keyword or
something um but guess what C++ is
technically not a super set of C either
correct it takes new keywords and so
it's fine like we as a community can
manage that it's not that big deal yeah
kind of Switching gears here uh yeah you
obviously have created a lot of really
large projects and these are these
aren't just weekend projects they are
multi-year projects and they're still
going on today and you've done a lot
you've you've stated that you learn by
building and so you said how hard is a c
compiler so you just started working on
it in nights and weekends and all that
and there's a lot of questions here that
I'm sure people would love to ask which
is like how do you choose your side
projects how do you stay motivated to
complete these but before you answer any
of those could you could you just kind
of give us like how do you even manage
your time exploring these new Concepts
versus working on the things that are
already huge to begin with such as like
how do you switch from llvm to the next
thing how do you switch from Swift to
the next thing without just getting
bogged down with all these like requests
for new things or your insights into
things so I thought you're GNA be nice
to me and now you're pointing out that
I've like an attention problem and I
can't stay something for more than eight
years
all you need attention is all you need
there you go um well all seriousness um
so I'm unusual in many ways um you know
the one of the ways that I'm unusual is
that I love to build things understand
them but I also do get along with humans
sometimes and I try I try hard and I'm
learning I'm getting better as I as I
grow and so um take take Swift for
example right um in the case of Swift it
was nights and weekends project for a
year and a half at that time I was
managing a team of 40 people or
something I don't remember exactly with
you know the the debugger which is
itself a team the clang stuff with
Objective C and C++ and all that kind of
stuff and um LV we built an entire code
generator for Apple's gpus to make it so
that Apple could insource its Hardware
design and so tons any there's tons of
stuff going on within my team maybe it
was bigger than I don't remember but the
uh um and so like I had a day job but uh
but each of those projects
um had gone from being something that
got catalyzed something got built out
something got proved and validated to
now there's a whole team around it that
was building it and they're doing it
better than I was right and so I me me
trying to be an engineer on the team as
a poter her boss as a managers or
whatever it's these amazing Engineers
full-time job like I add a lot of value
the value I adding is maybe architect
maybe as helping with problem solving
pointing them the right way classical
manager Tech lead manager type of rules
and uh me as a technologist like I like
to build things like You're were talking
about and so that means I then start
looking around and saying okay well
what's the next logical thing to work on
and so um that's where again clang clang
or Swift or uh uh things like this it
was more about it's no okay there's no
ambition for it to become anything big
it was more about just build some stuff
see see where it goes when Swift you
know i' work at it for a year and a half
it wasn't because ah I want to do world
comination it's more it's more about
okay well let's just see see what what
there is to do here and I have some
ideas let's prototype some stuff let's
have some fun and build in it's very
fast when you only have something in
your head you can spin very quickly and
you don't have to have meetings and so
it's very fun in a different way but
then to your point what happens is then
you want to get beyond what you can do
in your spare time it becomes more
important you understand it you can
explain it then you start bringing more
people there becomes a team then there
becomes a tech lead or a manager and
then and then at that point I can grow
out of it and do this
um one of the things I've
discovered across the years which is not
obvious is that um because I've kind of
been in this role of like invention
creation Innovation for so long um it
it's super funny I for example I was
working with the team at Google we're
building high performance runtime for
machine learning stuff and um like just
getting within the Google confines the
approval air quotes which was massively
not defined uh of like consensus of yes
we should build a new runtime for
tensorflow like achieving that was this
massive heroic effort just political and
just gigantic mous um we got consensus
to do this and then got the I had a team
and it's like okay team go and and it's
like space is clear let's go let's go
build this thing it's really important
go right and I was doing a bunch of
other things at the time I'm like hey go
right and and nobody could do anything
and what I realized
is that again brilliant Engineers right
this is again Google and um working on
machine learning infrastructure and high
performance accelerators and tpus and
stuff like this what I'd realized over
time is that um these amazing Engineers
had only ever worked on a mature project
it only added a feature or fixed a bug
or they jumped into a big code base
particularly at Google um you know the
the strong Engineers the experienced
Engineers like their major feature is
that they can absorb a huge amount of
complexity fit in their head and then
figure out the way to logically hill
climb the thing that they have and
outside of college very few people have
the opportunity to build something from
scratch so you're sitting there and
you're saying okay in front of us is
this you know I'm standing on the edge
of a cliff looking off into space you
know like and and to me I'm like oh I
can see a castle over there and I can
see this thing over here and I can see
how this all goes together and for other
people it's just terrifying because they
didn't know where to start and so
there's all these um again what I've
across the years because
you know getting more experience with
things um there's these patterns and
what I've seen is that there's folks
that will start from space and just be
paralyzed there'll be other folks that
just say like oh okay well I'm going to
build a new thing well there's this old
thing I've already worked on I know that
it works let's just reimplement that and
so the thing I like to do is I like to
say okay well we're GNA build a new high
performance machine in own time or a
language or whatever the starting point
for me is not um go hack up the thing
that I saw before it's go study all of
the things now when I was working on
Swift it was so was great you know was
kind of in parallel with grade and
working on Rust and things like this um
but also there's a bunch of other
languages that were really cool both
modern and also like okam for example
yes to fan and hle and things like this
but also uh really older ones as well
like some of the fundamental ones like
clue clu and things like this that many
people don't remember and so going and
studying and looking at um like Dart for
example right it's a very in very
specific domain that it wants to live in
and it makes a bunch of decisions it's
very specific to the problems it's
trying to solve but the way it did
Unicode escape and strings is really
cool and so we said yoink I'm G to take
that and put that in Swift and that's
the best way to do it way better than
what SE did or whatever it is and so my
Approach is generally do that research
do that survey and build a picture you
know build that what that castle looks
like out in space so I know what I'm
trying to get to and then iterate and
refine it over time and so I don't even
remember what your question is more but
um that's okay I have a good followup
anyways uh so I think this is like one
of the biggest weakness of all Engineers
is not knowing when to quit which is
either they quit too soon or they quit
too late how do you know what like
staying up for a year and a half on
nights and weekends programming Swift
when did you know like oh I shouldn't
quit this or how do you know oh I should
quit this and pursue something different
like what what is that kind of uh
thought process you have for quitting
well let me give you let me give you a
uh a modern example of modular so I
assume most of your folks don't know
what modular is about and so I'll give
you some context right so uh uh context
here is that AI is exploding super
annoying in lots of different ways
because there lots ofz and stupidity and
stuff like this floing but the systems
level the foundational infrastructure
underneath it is very profound very
important and AI despite some of the
Annoying stuff is also so really
important and there are really important
use cases at scale for businesses and
there's there's a big there there okay
now the problem with it is that the
technology platform this is all running
on is a gigantic freaking meth and
there's Cuda for example there's like
you know when training there's still
things like MPI and there's like all
this stuff is just this gigantic
nightmare of Technologies and it's and
it's never been really thought out and
so one of the things I realized is um
actually gave a talk several years ago
this as plus conference and if you want
you can find a link uh it was 2021 um I
gave it I gave a talk about you know
it's the Golden Age of compilers because
there's all this hardware and what we
need to do is we need to build a
unifying theory that allows us to
innovate in hardware and be able to get
all this stuff you know get software
developers to be able to build on a
common platform so that you can then uh
scale across all the different kinds of
Hardware because most of us all software
Engineers don't want to rewrite in our
entire app every time the thing changes
right the the hardware changes right we
want we want this and also by the way
the hardware people don't want to
reinvent an entire software stack every
time they want to come out with a new
chip basic observation and so um and so
when we started modular we said let's
how do we solve that problem and so here
here's here's the
Ridiculousness you know because you're
giving me a hard time you're saying
Chris you do these possible things right
um actually push this on stack like and
give you an example it's like like when
I joined Apple at a school to work on LM
like within the first month the very
senior lead of the GCC team comes up to
me and says Chris why are you working on
this lvm thing it's an academic research
project hundreds of people have been
working on GCC for decades like you're
doomed to failure why are you even
bothering just work on GCC right and
when working on Swift it's like
languages never work right again it's
phrase generally more passive
aggressively than this but new languages
never work nobody ever adopts them
languages are too expensive to build
blah blah blah you're doomed to failure
and so I've been told I'm doomed to
failure so many times it's it's I'm I'm
pretty used to it um Twitter only
amplifies it and makes it more frequent
but it's all good um and so with modular
you go into this you say well what is
our objective our objective is not just
to build a unifying platform for this
next Generation heterogeneous compute
CPUs gpus accelerators all these new
things are so important to the world but
it's to beat the state-of-the-art of the
hardware vendors on their own
chips well how do you do that you talk
about rust how can you be faster than
rust like how can you be Intel who's
been building software for their chips
for 20 years they know their chips
better than anybody else how can you be
Intel in their own chips right and so we
started out with the company is we said
okay well let's go we have a hypothesis
that we can do this and how what how's
the hypothesis shaped well um built a
new compiler framework called ml which
is kind of like you can think of as like
a successor to lovm
it was really cool really profound
nobody understood how it
worked there's a bunch of new algorithms
there's a bunch of ways to be able to
generate code when you get into this
accelerator space and the high
performance compute even on CPUs um you
have to use the hardware blocks like
because all these things have matrix
multiplication operations now and like
all the stuff is built into even CPUs
but definitely accelerators right so the
entire game which by the way none of
Swift or rust or any of these languages
even attempt to solve they can barely do
simd U but the entire game is how do you
actually utilize a modern computer and
now your multicore on servers you have
multiple sockets and so you have what's
called Numa so the memory access
patterns are very different depending on
where you're doing your accesses from
and so nothing in this world has been
designed for this kind of computer and
you look at um again I'm not anti- inel
or anything but you look at General
hyper software and it was written for
tips 20 years ago and so what we did
coming back your point of how do you
know when to quit because we said okay
let's build some really crazy ass
high-tech stuff that nobody else in the
world knows how to do like very
different architecturally yes you need a
high performance asynchronous runtime on
the bottom yes you need a entirely new
threadpool you need you need an entirely
new way to program simd you need an
entirely new way to uh generate code and
do automatic what's called fernal Fusion
so you get rid of memory traffic
entirely and things like this let's
build this really fancy compiler thing
and in in in a way that we could show
that we could generate Matrix
multiplications that run faster than
Intel Intel mkl on Intel
chips and we built all that kind of
stuff out and like good scientists and
you want to validate the hypothesis and
so we we built this really fancy
compiler stuff um that nobody else has
and then we showed and we proved to
ourselves that yes we could beat Intel's
best Drag Racing on their chips even
though they have thousands of like
insanely amazing people writing an
assembly code um and that what we proved
is that the generality of a compiler
beats humans special casing individual
Point Solutions because humans can't
scale the compiler can scale and this is
again a very different generation of
Technology than something like lvm right
and so the problem then we had was we
got to the end of uh this was the end of
2022 and we said cool we have this
really fancy compiler stuff we can do
this we can generate code problem is
that there's like three people in the
world that can possibly understand this
because you have to be able to
understand all of the compiler and all
of this crazy stuff and we we validated
that yes we can do it so let's not stop
but then we said well how are we now
going to program this stuff and then we
said well I need
syntax and then we went shopping for
syntax and then we decided Python and
then dot dot dot that's what Mojo
is right and so Mojo was not Mo Mojo is
not a like let's go build a language for
fun Ojo was a solution to a series of
equations of we have this really fancy
compiler stuff built forne generation
acceler and gpus and all this kind of
stuff now we need syntax and python is
the obvious syntax but we can't use the
python implementation or the Swift
implementation or any of these compilers
because they don't have any of the right
guts inside of them and so that's that's
the world that Mojo is coming out of one
of the interesting things about Mojo I
think this probably the last one before
we move Prime is my understanding is
Mojo is like effectively just an an as4
ml right that's what you've said before
there's sort of like it's a direct like
link to mli
that that is true um but that really
under so that that is absolutely true
and there's an incredibly valuable thing
about that which I expect most folks
won't won't grock but uh many of today's
systems whether it be on your desk like
you know an apple silicon thingy but but
also these very fancy data center
accelerator things they're very
different computers and so the way you
need to program them is very different
and ml is the right way to do that the
problem with ML and this is another
thing that annoys me to no end is that
ml which is now an lvm Pro so it's part
of the lvm Ella has all this super
academic crazy stuff in the in the
project and and we use almost none of
that we don't use the ml dialects at all
and so not only do we not only are we
the only language that front ends to ml
which is itself a very important thing
when talking to all the asex and stuff
like this but we've rebuilt the entire
compiler stack from scratch and so this
is again when you say how can you be
faster than x it's like well we have a
completely different stack we've built
from scratch it's it's it is actually
new technology and I think that's where
people are I mean maybe it's part of the
success of lvm is everybody just buildt
on top of LM and they're like they're
all the same and so people like oh okay
well languages are all the same if
they're zero cost subtractions and it's
like well that's true if you're all
using the same code generator but if
you're doing something new then it's not
all the same so that's a great answer I
I now submit that Mojo can be faster
than Russ now that I know that you're
swapping out what uh what car you're
driving yeah yeah and and again lvm is a
good thing but lm's 20 plus years old
right I mean it's it's it's a good thing
and I mean I'll just speak for myself
I've learned so many
lessons and very proud of what it's been
able to do and it's contribution to the
world but it's not it's not perfect by
stretch of imagination I know I know the
problems better than anybody um in fact
if you if you look at the lvm developer
meeting uh last fall we gave a talk
about Mojo and we explained it's like we
use lvm the good parts not the lvm
system well thank you very much Chris
for joining us uh for the remainder of
the time because we have you just for a
little bit longer I know you got a
something here in about 20 or uh yeah
about what is that 19 minutes uh we're
going to switch over to the Discord uh
I'll stop The Stream and then I'll walk
you through exactly what to do and we'll
feel a couple questions from the top
shelf for those that are on the top
shelf that would be tier 2 tier 3es from
twitch you get to go over and then
anyone that has a sufficiently neurotic
question I will then ask Chris that
question and we'll see how it goes uh
all right hey thank you very much for
coming on really appreciate it by the
way just it absolutely just a treat to
talk to you and just the things you've
accomplished are truly an inspiration to
a lot of people in the chat a lot of
people said you've made like you were an
inspiration for Part of Me programming
and all that so thank you for everything
you do that's amazing yeah Al so I mean
I I'm very happy that the things my Nery
little projects are interesting and
useful for people and so it's it's
amazing they're not just useful they're
I mean we wouldn't have a lot of our
modern languages without it so I love
Zig and Zig is currently on lovm so I'm
sure I don't even know if it would be
possible to have Zig without that in its
current state so thank you I I I also
love Zig so um ask so many questions
about Zig oh man yeah well a lot of Zig
is in Mojo including the entire meta
programming system so I mean that's
comp we'll talk about it in the top go
to the topop getting distra this is this
this is again people are not used to the
fact that progress is being made all the
time and so you have to learn from it
all right awesome all right hey
everybody thank you for joining uh we're
off to the Discord